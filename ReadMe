Method:
healthy_leafs = [h_leaf1, h_leaf2, h_leaf3...]
corrupted_leafs = [c_leaf1, c_leaf2, c_leaf3...]
rust = [ rust1, rust2, rust3..]

test_leaf = [t_leaf1, t_leaf2, t_leaf3...]

comparison between t_leaf1, healthy_leafs and corrupted_leafs
if no_matches in healthy_leafs > corrupted_leafs -> t_leaf1 is healthy
if not t_leaf1 is corrupted

if t_leaf1 is corrupted match it with rust pictures and circle the matching ones.







low_thresh = 5
up_thresh = 100
img1_edges = cv2.Canny(img1_blur, low_thresh, up_thresh)
img1_contours, hierarchy1 = cv2.findContours(img1_edges, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
img1_drawing = np.zeros((img1.shape[0], img1.shape[1], 3))
img1_drawing.fill(255)
cv2.drawContours(img1_drawing, img1_contours, -1, (0, 0, 0))






# convert to hsv colorspace
hsv = cv2.cvtColor(img1, cv2.COLOR_BGR2HSV)

# lower bound and upper bound for Green color
lower_bound = np.array([25, 0, 60])
upper_bound = np.array([255, 255, 255])

# find the colors within the boundaries
mask = cv2.inRange(hsv, lower_bound, upper_bound)

#define kernel size
kernel = np.ones((5,5),np.uint8)

# Remove unnecessary noise from mask
mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

segmented_img = cv2.bitwise_and(img1, img1, mask=mask)
cv2.imshow('', segmented_img)
cv2.waitKey(0)